# 8. Zustand によるグローバル状態管理

本章では、**Zustand** を導入して、アプリケーション全体で共有すべき「クライアント状態（Client State）」を管理します。

## 8.1 Zustand とは

Zustand（ドイツ語で「状態」の意味）は、Reactのための非常にシンプルで軽量な状態管理ライブラリです。
Redux のような複雑なボイラープレート（Action, Reducer, Dispatch...）が不要で、React Context API よりもパフォーマンスチューニング（不要な再レンダリングの抑制）が容易という特徴があります。

また、最大の特徴として **「Reactコンポーネントの外側（普通の関数やクラス）からも状態にアクセス・更新ができる」** という点があります。

通常、React の状態（`useState` や `useContext`）は、**React コンポーネントやカスタムフックの中でしか利用できません**（フックのルール）。
そのため、「API通信を行うユーティリティ関数（ただのTypeScriptファイル）」の中から、「画面のローディング状態をONにしたい」と思っても、直接 `setState` を呼ぶことはできませんでした。

しかし Zustand は、フックを使わずにストアの実体に直接アクセスする方法を提供しています。
これにより、**「APIクライアントが通信を開始したら、自動的にローディング状態をONにする」** といった連携が、コンポーネントを介さずに非常にシンプルに実装できます。

## 8.2 認証機能の実装 (User Store)

まずは、多くのアプリケーションで必要となる「認証機能（ログインユーザー管理）」を実装しながら、Zustandの基本的な使い方を学びます。

この章では下記ブランチを利用します。
`ch8-2/user-store`

### 8.2.1 インストール

```bash
pnpm add zustand
```

### 8.2.2 ユーザー情報の型定義

まず、ログインユーザーの型を定義します。

`app/types/login-user.ts`:
```typescript
export interface LoginUser {
  userId: string;
  userName: string;
  roles: string;
}
```

### 8.2.3 User Store の作成

ユーザー情報を管理するストアを作成します。
`create` 関数を使ってストアを作成し、状態（`user`）と更新関数（`login`, `logout`）を定義します。

`app/stores/user-store.ts`:
```typescript
import { create } from 'zustand';
import type { LoginUser } from '../types/login-user';

interface UserState {
  user: LoginUser | null;
  login: (user: LoginUser) => void;
  logout: () => void;
}

export const useUserStore = create<UserState>()((set) => ({
  user: null,
  login: (user) => set({ user }),
  logout: () => set({ user: null }),
}));
```

### 8.2.4 モックサーバーの更新

認証用のエンドポイントを追加します。

`mock_server/server.js`:
```javascript
// ... existing code ...

const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// POST /login
app.post('/login', async (req, res) => {
  console.log('POST /login', req.body);

  await sleep(2000);

  const { userId, password } = req.body;
  
  const user = {
    userId: userId,
    userName: "テストユーザー",
    roles: "admin",
  };
  res.json(user);
});

// POST /logout
app.post('/logout', async (req, res) => {
  console.log('POST /logout');

  await sleep(2000);
  
  res.status(200).json({ message: 'ログアウトしました' });
});
```

### 8.2.5 認証APIの実装

ログイン・ログアウトを行うAPI関数を定義します。

`app/features/auth/api.ts`:
```typescript
import { api } from "../../core/api/api-client";
import type { LoginUser } from "../../types/login-user";
import type { CustomLoginRequest } from "./types";

export const login = async (data: CustomLoginRequest): Promise<LoginUser> => {
  return api.post<LoginUser>("/login", data);
};

export const logout = async (): Promise<void> => {
  return api.post<void>("/logout");
};
```

### 8.2.6 認証フックの実装 (useAuth)

認証ロジックをまとめたカスタムフックを作成します。
TanStack Query の `useMutation` を使用してAPIを呼び出し、成功時に Zustand ストアを更新します。

`app/features/auth/hooks/useAuth.ts`:
```typescript
import { useState } from "react";
import { useMutation } from "@tanstack/react-query";
import { useUserStore } from "../../../stores/user-store";
import { login as loginApi, logout as logoutApi } from "../api";

export interface UseAuthState {
  isSubmitting: boolean;
  onLogin: (e: React.FormEvent<HTMLFormElement>) => void;
  error: string | null;
  onLogout: () => void;
}

/**
 * 認証機能用のカスタムフック
 * @param onClose - ログインモーダルを閉じるコールバック関数（任意）
 * @returns 認証機能で使用する関数や状態を含むオブジェクト
 */
export function useAuth(onClose?: () => void): UseAuthState {
  const [error, setError] = useState<string | null>(null);
  
  // ストアからアクションを取得
  // 注: オブジェクトとしてまとめて取得すると再レンダリングの原因になるため、個別に取得します
  const login = useUserStore((state) => state.login);
  const logout = useUserStore((state) => state.logout);

  const loginMutation = useMutation({
    mutationFn: loginApi,
    onSuccess: (data) => {
      login(data); // ストア更新
      onClose?.();
      setError(null);
    },
    onError: (err) => {
      console.error(err);
      setError("社員番号、または、パスワードが正しくありません。");
    },
  });

  const logoutMutation = useMutation({
    mutationFn: logoutApi,
    onSuccess: () => {
      logout(); // ストア更新
    },
    onError: (err) => {
      console.error("Logout failed", err);
    },
  });

  const onLogin = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError(null);
    const formData = new FormData(e.currentTarget);
    const userId = formData.get("userId") as string;
    const password = formData.get("password") as string;

    loginMutation.mutate({ userId, password });
  };

  return {
    isSubmitting: loginMutation.isPending,
    onLogin,
    error,
    onLogout: () => logoutMutation.mutate(),
  };
}
```

### 8.2.7 UIコンポーネントの実装

**ログインモーダル**

`app/features/auth/components/LoginModal.tsx`:
```tsx
import type { JSX } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  Box,
  Typography,
} from "@mui/material";
import { useAuth } from "../hooks/useAuth";

interface LoginModalProps {
  open: boolean;
  onClose: () => void;
}

export function LoginModal({ open, onClose }: LoginModalProps): JSX.Element {
  const {
    isSubmitting,
    onLogin,
    error,
  } = useAuth(onClose);

  return (
    <Dialog open={open} onClose={onClose} maxWidth="xs" fullWidth>
      <DialogTitle>ログイン</DialogTitle>

      <form onSubmit={onLogin} noValidate>
        <DialogContent>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3, mt: 1 }}>
            <TextField
              name="userId"
              label="社員番号"
              autoComplete="username"
              fullWidth
              required
            />
            <TextField
              name="password"
              label="パスワード"
              type="password"
              autoComplete="current-password"
              fullWidth
              required
            />
          </Box>

          {error && (
            <Typography color="error" sx={{ mt: 1 }}>
              {error}
            </Typography>
          )}
        </DialogContent>

        <DialogActions>
          <Button onClick={onClose} disabled={isSubmitting}>
            キャンセル
          </Button>
          <Button type="submit" variant="contained" disabled={isSubmitting}>
            {isSubmitting ? '送信中...' : 'ログイン'}
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
}
```

**ヘッダー**

ヘッダーでは `useUserStore` を使ってユーザー情報を取得し、表示を切り替えます。

`app/components/Layout/SampleHeader.tsx`:
```tsx
// ... imports

export function SampleHeader({ onMenuClick }: HeaderProps): JSX.Element {
  const user = useUserStore((state) => state.user);
  const { onLogout } = useAuth();
  const [isLoginModalOpen, setIsLoginModalOpen] = useState(false);

  const handleLoginClick = () => {
    setIsLoginModalOpen(true);
  };

  const handleLogoutClick = () => {
    onLogout();
  };

  return (
    <>
      <AppBar position="fixed" sx={{ zIndex: theme => theme.zIndex.drawer + 1 }}>
        <Toolbar>
          {/* ... メニューアイコンなど */}

          <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
            React Demo アプリ
          </Typography>

          {user ? (
            <>
              <Typography variant="body1" sx={{ mr: 2 }}>
                {user.userName} さん
              </Typography>
              <Button color="inherit" onClick={handleLogoutClick}>
                ログアウト
              </Button>
            </>
          ) : (
            <Button color="inherit" onClick={handleLoginClick}>
              ログイン
            </Button>
          )}
        </Toolbar>
      </AppBar>
      <LoginModal open={isLoginModalOpen} onClose={() => setIsLoginModalOpen(false)} />
    </>
  );
}
```

## 8.3 グローバルローディングの実装 (Loading Store)

次に、API通信中に画面全体にローディングスピナーを表示する「グローバルローディング」を実装します。

この章では下記ブランチを利用します。
`ch8-3/loading-store`

### 8.3.1 Loading Store の作成

ローディング状態を管理するストアです。
複数のAPIリクエストが同時に走ることを考慮し、`boolean` ではなく `loadingCount` (数値) で管理します。
カウントが1以上ならローディング中とみなします。

`app/stores/loading-store.ts`:
```typescript
import { create } from "zustand";

type LoadingStore = {
  /** 現在実行中の非同期処理の数 */
  loadingCount: number;
  /** ローディング中かどうか（loadingCount > 0 の場合に true） */
  isLoading: boolean;
  /** ローディングを開始する（カウントを増やす） */
  startLoading: () => void;
  /** ローディングを終了する（カウントを減らす） */
  endLoading: () => void;
};

export const useLoadingStore = create<LoadingStore>((set, get) => ({
  loadingCount: 0,
  isLoading: false,
  startLoading: () => {
    const next = get().loadingCount + 1;
    set({ loadingCount: next, isLoading: true });
  },
  endLoading: () => {
    const next = get().loadingCount - 1;
    // カウントがマイナスにならないように制御し、0になったらローディング終了とする
    set({
      loadingCount: next < 0 ? 0 : next,
      isLoading: next <= 0 ? false : true,
    });
  },
}));
```

### 8.3.2 Loading Spinner コンポーネント

ストアの `isLoading` を監視して表示されるコンポーネントです。

`app/components/elements/LoadingSpinner.tsx`:
```tsx
import Backdrop from '@mui/material/Backdrop';
import Box from '@mui/material/Box';
import CircularProgress from '@mui/material/CircularProgress';
import type { JSX } from 'react';
import { useLoadingStore } from '~/stores/loading-store';

export const LoadingSpinner = (): JSX.Element | null => {
  const isLoading = useLoadingStore(s => s.isLoading);

  if (!isLoading) return null;

  return (
    <Backdrop
      sx={{
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        color: '#fff',
        zIndex: 9999,
      }}
      open={isLoading}
    >
      <Box display="flex" flexDirection="column" alignItems="center" gap={2}>
        <CircularProgress color="inherit" />
      </Box>
    </Backdrop>
  );
};
```

このコンポーネントを `app/root.tsx` などのルートコンポーネントに配置します。

```ts
export default function App() {
  return (
    <ThemeProvider theme={theme}>
      <QueryClientProvider client={queryClient}>
        <CssBaseline />
        <SampleLayout>
          <Outlet />
        </SampleLayout>
        <LoadingSpinner />
      </QueryClientProvider>
    </ThemeProvider>
  );
}
```

### 8.3.3 APIクライアントとの連携 (Interceptors)

Axios の Interceptor を使って、リクエスト開始時に `startLoading`、終了時に `endLoading` を自動的に呼び出します。
ここで `useLoadingStore.getState()` を使うことで、フックを使わずにストアを操作しています。

`app/core/api/api-client.ts`:
```typescript
import Axios, { type AxiosInstance, type AxiosRequestConfig } from "axios";
import { useLoadingStore } from "../../stores/loading-store";

// ... (Axiosインスタンス作成など)

// ストアのインスタンスを取得するヘルパー
const getLoadingStore = () => useLoadingStore.getState();

const requestInterceptor = (config: any) => {
  // ローディング開始
  getLoadingStore().startLoading();

  // ログ出力
  console.log(`[Request] ${config.method?.toUpperCase()} ${config.url}`);

  // ... (認証ヘッダー付与など)
  return config;
};

const responseSuccessInterceptor = (response: any) => {
  // ローディング終了
  getLoadingStore().endLoading();
  return response.data;
};

const responseErrorInterceptor = (error: any) => {
  // ローディング終了
  getLoadingStore().endLoading();
  return Promise.reject(error);
};

// Interceptorの登録
api.interceptors.request.use(requestInterceptor, (error) => {
  // リクエスト設定時にエラーが発生した場合（送信前）、ローディングを終了させる
  getLoadingStore().endLoading();
  return Promise.reject(error);
});
api.interceptors.response.use(responseSuccessInterceptor, responseErrorInterceptor);
```

### メリット

この仕組みを作ることで、各画面（コンポーネント）ごとに `const [isLoading, setIsLoading] = useState(false)` を定義して、APIを呼ぶたびに `true/false` を切り替える...といった**退屈な作業が一切不要**になります。
APIを呼べば勝手にスピナーが出て、終われば勝手に消えるようになります。

## 8.4 まとめ

本章では、Zustand を用いたグローバルな状態管理について学びました。

*   **Zustand の特徴**: シンプルな API で、コンポーネント外（Axios Interceptor など）からも容易に状態にアクセスできる点が強力です。
*   **User Store**: ログインユーザー情報を管理し、ヘッダー表示や認証ガードなどに利用します。
*   **Loading Store**: API 通信の開始・終了に合わせて自動的にローディングスピナーを表示する仕組みを構築しました。
*   **Axios Interceptor との連携**: API クライアント側でローディング制御を共通化することで、各画面での実装コストを大幅に削減しました。

これで、アプリケーションの基盤となる「認証」と「ローディング」の実装が完了しました。
次章以降では、これらの基盤の上で、具体的な業務機能（商品管理など）の実装を進めていきます。