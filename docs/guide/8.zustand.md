# 8. Zustand によるグローバル状態管理

本章では、**Zustand** を導入して、アプリケーション全体で共有すべき「クライアント状態（Client State）」を管理します。

## 8.1 Zustand とは

Zustand（ドイツ語で「状態」の意味）は、Reactのための非常にシンプルで軽量な状態管理ライブラリです。  
Redux や Context API と比較しても、非常にシンプルなコードでグローバルな状態管理を実現できるのが特徴です。

基本的な実装パターンは以下の通りです。これだけの実装で、データをグローバルに管理するストアを作成・利用できます。  
ここでは、ログインユーザー情報を管理する「UserStore」を例にします。

```typescript
import { create } from 'zustand';

// 1. ストアの作成 (create)
type User = { id: string; name: string };

type UserStore = {
  user: User | null;
  setUser: (user: User) => void;
  clearUser: () => void;
};

const useUserStore = create<UserStore>((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  clearUser: () => set({ user: null }),
}));

// 2. コンポーネント内での利用 (Hooks)
function Header() {
  const user = useUserStore((state) => state.user);
  const setUser = useUserStore((state) => state.setUser);
  const clearUser = useUserStore((state) => state.clearUser);

  return (
    <header>
      {user ? (
        <>
          <div>{user.name}さん</div>
          <button onClick={clearUser}>ログアウト</button>
        </>
      ) : (
        <button onClick={() => setUser({ id: '1', name: 'Taro' })}>
          ログイン
        </button>
      )}
    </header>
  );
}
```

このように、Zustand は「ストアの作成」「状態の参照」「状態の更新」を非常に直感的かつ短いコードで記述できます。  
また、コンポーネント内で参照しているデータが更新されると、自動的に再レンダリングが行われるため、画面の同期も容易です。

本章では、これらの特徴を活かして「認証機能」と「API通信時のグローバルローディング」を実装しながら、Zustand の使い方を学んでいきます。


## 8.2 認証機能の実装 (User Store)

まずは、多くのアプリケーションで必要となる「認証機能（ログインユーザー管理）」を実装しながら、Zustandの基本的な使い方を学びます。

この章では下記ブランチを利用します。  
`ch8-2/user-store`

### 8.2.1 インストール

```bash
pnpm add zustand
```

### 8.2.2 Store作成の前準備

今回の認証機能ではzustandを用いてuser-storeを作成します。  
そのためにまずuser-storeで管理するLoginUser型と、LoginUser型のユーザー情報を返却するログインAPI（とログアウトAPI）を作成します。

`app/types/login-user.ts`:
```typescript
export interface LoginUser {
  userId: string;
  userName: string;
  roles: string;
}
```

`mock_server/server.js`:
```javascript
// ... existing code ...

// 実際の挙動に近づけるために、レスポンスを遅延させる関数
const sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// POST /login
app.post('/login', async (req, res) => {
  console.log('POST /login', req.body);

  await sleep(2000);

  const { userId, password } = req.body;
  
  const user = {
    userId: userId,
    userName: "テストユーザー",
    roles: "admin",
  };
  res.json(user);
});

// POST /logout
app.post('/logout', async (req, res) => {
  console.log('POST /logout');

  await sleep(2000);
  
  res.status(200).json({ message: 'ログアウトしました' });
});
```

### 8.2.3 User Store の作成

ユーザー情報を管理する`zustand`ストアを作成します。  
`create` 関数を使ってストアを作成し、状態（`user`）と更新関数（`setUser`, `clearUser`）を定義します。

※ `create<UserState>()(...)` のように括弧が2つ続く記述は、TypeScriptで型推論を正しく効かせるためのZustand特有の書き方です。

`app/stores/user-store.ts`:
```typescript
import { create } from 'zustand';
import type { LoginUser } from '../types/login-user';

interface UserState {
  user: LoginUser | null;
  setUser: (user: LoginUser) => void;
  clearUser: () => void;
}

export const useUserStore = create<UserState>()((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  clearUser: () => set({ user: null }),
}));
```

### 8.2.4 user-storeの更新関数の利用

認証ロジックをまとめたカスタムフック `useAuth` を作成します。  
ここでは、TanStack Query の `useMutation` でログインAPIを呼び出し、その成功時（`onSuccess`）に Zustand ストアの更新関数（`setUser`）を実行するパターンを確認します。

`app/features/auth/hooks/useAuth.ts`:
```typescript
export function useAuth(onClose?: () => void) {
  // 1. ストアから更新関数（Action）を取得
  const setUser = useUserStore((state) => state.setUser);
  const clearUser = useUserStore((state) => state.clearUser);

  const loginMutation = useMutation({
    mutationFn: (data: LoginRequest) => api.post<LoginUser>("/login", data),
    onSuccess: (data: LoginUser) => {
      // 2. API通信成功時にストアを更新する
      setUser(data);
      onClose?.();
    },
  });

  // フォーム送信ハンドラ
  const handleLogin = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const formData = new FormData(event.currentTarget);
    loginMutation.mutate({
      userId: formData.get("userId") as string,
      password: formData.get("password") as string,
    });
  };
  
  return {
    onLogin: handleLogin,
    isSubmitting: loginMutation.isPending,
    error: loginMutation.error,
  };
}
```

`app/features/auth/components/LoginModal.tsx`:
```tsx
export function LoginModal({ open, onClose }: LoginModalProps) {
  // useAuth フックを利用して、UIロジックを分離
  const { onLogin, isSubmitting, error } = useAuth(onClose);

  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>ログイン</DialogTitle>
      
      {/*ログインボタン押下でonLoginを実行*/}
      <form onSubmit={onLogin}>
        <DialogContent>
           {/* ... 入力フォーム (TextFieldなど) ... */}
        </DialogContent>
        <DialogActions>
          <Button onClick={onClose}>キャンセル</Button>
          <Button type="submit" disabled={isSubmitting}>
            ログイン
          </Button>
        </DialogActions>
      </form>
    </Dialog>
  );
}
```

### 8.2.5 user-storeの参照

ここでは `user-store` の状態（`user`）を参照して、画面表示を切り替える例を紹介します。
`SampleHeader` コンポーネントで、ログイン状態に応じて「ユーザー名」または「ログインボタン」を表示します。

下記のように認証状態によって表示が切り替わることが確認できます。
- ログアウト状態：ログインボタンが表示
- ログイン状態：ユーザー名とログアウトボタンが表示

`app/components/Layout/SampleHeader.tsx`:
```tsx
export function SampleHeader() {
  // 1. ストアから状態（State）を取得
  // セレクタ関数 (state) => state.user を使うことで、userが更新された時だけ再レンダリングされる
  // ※ const { user } = useUserStore() と書くと、ストア内の他の値が変わった時も再レンダリングされてしまうため注意
  const user = useUserStore((state) => state.user);
  
  const { onLogout } = useAuth();

  return (
    <AppBar>
      <Toolbar>
        {/* ... */}
        
        {/* 2. 取得した user の値によって表示を切り替え */}
        {user ? (
          <>
            <Typography>{user.userName} さん</Typography>
            <Button onClick={onLogout}>ログアウト</Button>
          </>
        ) : (
          <Button onClick={/* ログインモーダルを開く */}>
            ログイン
          </Button>
        )}
      </Toolbar>
    </AppBar>
  );
}
```

## 8.3 グローバルローディングの実装 (Loading Store)

次に、API通信中に画面全体にローディングスピナーを表示する「グローバルローディング」を実装します。

この章では下記ブランチを利用します。  
`ch8-3/loading-store`

### 8.3.1 Loading Store の作成

ローディング状態を管理するストアです。
ローディングスピナーの表示制御には `isLoading` (boolean) を使用しますが、その内部ロジックには `loadingCount` (数値) を利用します。

単純な `boolean` の切り替え（開始でtrue、終了でfalse）だけでは、複数のAPIリクエストが同時に走った際に問題が起きます。
例えば、リクエストAとBが並行して走っている場合、Aが先に終わって `false` に設定してしまうと、Bがまだ実行中であるにも関わらずスピナーが消えてしまいます。

そこで、「実行中のリクエスト数」をカウントし、「カウントが0より大きい場合は `isLoading` を true にする」というロジックにすることで、すべてのリクエストが完了するまでスピナーを表示し続けることができます。

`app/stores/loading-store.ts`:
```typescript
import { create } from "zustand";

type LoadingStore = {
  /** 現在実行中の非同期処理の数 */
  loadingCount: number;
  /** ローディング中かどうか（loadingCount > 0 の場合に true） */
  isLoading: boolean;
  startLoading: () => void;
  endLoading: () => void;
};

export const useLoadingStore = create<LoadingStore>((set, get) => ({
  loadingCount: 0,
  isLoading: false,
  startLoading: () => {
    const next = get().loadingCount + 1;
    set({ loadingCount: next, isLoading: true });
  },
  endLoading: () => {
    const next = get().loadingCount - 1;
    // カウントがマイナスにならないように制御し、0になったらローディング終了とする
    set({
      loadingCount: next < 0 ? 0 : next,
      isLoading: next <= 0 ? false : true,
    });
  },
}));
```

### 8.3.2 Loading Spinner コンポーネント

`loading-store`の `isLoading` を監視して、`isLoading=true`の場合に表示されるコンポーネントです。

`app/components/elements/LoadingSpinner.tsx`:
```tsx
import Backdrop from '@mui/material/Backdrop';
import Box from '@mui/material/Box';
import CircularProgress from '@mui/material/CircularProgress';
import type { JSX } from 'react';
import { useLoadingStore } from '~/stores/loading-store';

export const LoadingSpinner = (): JSX.Element | null => {
  const isLoading = useLoadingStore(s => s.isLoading);

  if (!isLoading) return null;

  return (
    <Backdrop
      sx={{
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        color: '#fff',
        zIndex: 9999,
      }}
      open={isLoading}
    >
      <Box display="flex" flexDirection="column" alignItems="center" gap={2}>
        <CircularProgress color="inherit" />
      </Box>
    </Backdrop>
  );
};
```

このコンポーネントを `app/root.tsx` などのルートコンポーネントに配置することで、`loading-store`の`isLoading=true`の場合のみ`LoadingSpinner`が表示されるようにします。

```ts
export default function App() {
  return (
    <ThemeProvider theme={theme}>
      <QueryClientProvider client={queryClient}>
        <CssBaseline />
        <SampleLayout>
          <Outlet />
        </SampleLayout>
        <LoadingSpinner />
      </QueryClientProvider>
    </ThemeProvider>
  );
}
```

### 8.3.3 APIクライアントとの連携 (Interceptors)

Axios の Interceptor を使って、リクエスト開始時に `startLoading`、終了時に `endLoading` を自動的に呼び出します。
ここで `useLoadingStore.getState()` を使うことで、フックを使わずにストアを操作しています。

`app/core/api/api-client.ts`:
```typescript
import Axios, { type AxiosInstance, type AxiosRequestConfig } from "axios";
import { useLoadingStore } from "../../stores/loading-store";

// ... (Axiosインスタンス作成など)

// ストアのインスタンスを取得するヘルパー
const getLoadingStore = () => useLoadingStore.getState();

const requestInterceptor = (config: any) => {
  // ローディング開始
  getLoadingStore().startLoading();

  // ... (認証ヘッダー付与など)
  return config;
};

const responseSuccessInterceptor = (response: any) => {
  // ローディング終了
  getLoadingStore().endLoading();
  return response.data;
};

const responseErrorInterceptor = (error: any) => {
  // ローディング終了
  getLoadingStore().endLoading();
  return Promise.reject(error);
};

// Interceptorの登録
api.interceptors.request.use(requestInterceptor, (error) => {
  // リクエスト設定時にエラーが発生した場合（送信前）、ローディングを終了させる
  getLoadingStore().endLoading();
  return Promise.reject(error);
});
api.interceptors.response.use(responseSuccessInterceptor, responseErrorInterceptor);
```

この仕組みを作ることで、各画面（コンポーネント）ごとに `const [isLoading, setIsLoading] = useState(false)` を定義して、APIを呼ぶたびに `true/false` を切り替える...といった**退屈な作業が一切不要**になります。
APIを呼べば勝手にスピナーが出て、終われば勝手に消えるようになります。

## 8.4 まとめ

本章では、Zustand を用いたグローバルな状態管理について学びました。

本章の実装を通して、以下の点が確認できました。

1.  **認証機能の実装**
    *   ストアの更新や参照、それに基づくコンポーネントの表示切り替えが、非常に簡単に実装できました。

2.  **高度な機能の連携**
    *   Loading Store と Axios を連携させることで、「API実行時に共通のローディングを表示する」という強力な機能を、手軽に実現できました。

このように、Zustand を使うことで **「シンプルで分かりやすい」** ストアを作成できます。
コードがシンプルであることは、**「開発スピードの向上」** や **「変更のしやすさ」** に直結します。
複雑になりがちな状態管理をシンプルに保てることは、長期的なアプリケーション開発において大きな武器となります。
