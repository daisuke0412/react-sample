# 9. React Hook Form & Zod によるフォーム開発

本章では、**React Hook Form** と **Zod** を導入して、より堅牢で開発効率の高いフォーム実装を行います。

この章では下記ブランチを利用します。  
`ch9/form-validation`

## 9.1 フォームライブラリの必要性

5章で実装した標準的なフォーム実装（`FormData` や `useState`）には、フォームが複雑になるにつれて以下のような課題が生じやすくなります。

1.  **バリデーションロジックの肥大化**: 必須チェック、形式チェック、相関チェックなどを自前で書くとコードが複雑になる。
2.  **型安全性の欠如**: `FormData` から取得した値はすべて `string` や `File` になるため、数値への変換や型キャストが必要になる。
3.  **パフォーマンス**: `useState` で入力を管理すると、一文字入力するたびに再レンダリングが発生する（React Hook Form はこれを回避できる）。

これらの課題を解決するために、以下のライブラリを組み合わせる構成が、現在のReact開発の鉄板ライブラリとなっています。

*   **React Hook Form**: 非制御コンポーネントベースの軽量なフォームライブラリ。再レンダリングを最小限に抑える。
*   **Zod**: TypeScript First のスキーマ宣言・バリデーションライブラリ。

## 9.2 フォームライブラリ開発

それでは、実際にライブラリを導入してフォームを開発していきます。

### 9.2.1 ライブラリのインストール

まずは必要なライブラリをインストールします。
フォーム管理本体の `react-hook-form`、バリデーションスキーマ定義用の `zod`、そして両者を連携させるための `@hookform/resolvers` を追加します。

```bash
pnpm add react-hook-form zod @hookform/resolvers
```

### 9.2.2 Zod によるスキーマ定義

バリデーションルールを「スキーマ」として定義します。
`app/features/items/schema.ts` を作成し、以下のように記述します。

**app/features/items/schema.ts**

```typescript
import { z } from "zod";

export const itemSchema = z.object({
  name: z.string().min(1, "商品名は必須です"),
  price: z
    .number()
    .min(1, "価格は1円以上で入力してください")
    .int("価格は整数で入力してください"),
  description: z.string().optional(),
});

// スキーマから型を自動生成
export type ItemInput = z.infer<typeof itemSchema>;
```

各フィールドのバリデーション内容は以下の通りです。

*   **name**: 必須項目（1文字以上）
*   **price**: 必須項目、1以上の整数
*   **description**: 任意項目（文字列）

### 9.2.3 React Hook Form の導入とUI実装

作成したスキーマを使ってフォームコンポーネントを実装します。
`app/features/items/pages/ItemCreatePage.tsx` を修正します。

`useForm` フックを使用し、`resolver` オプションに Zod スキーマを渡すことで、バリデーションロジックを自動的に適用できます。
また、MUI の `TextField` などのコンポーネントと連携させるには、`register` 関数を使用します。

```tsx
import { useItemCreate } from "../hooks/useItemCreate";
import { Box, Button, TextField, Alert, Paper, Typography } from "@mui/material";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { itemSchema, type ItemInput } from "../schema";

export function ItemCreatePage() {
  const { mutateAsync, isSubmitting, errorMessage } = useItemCreate();
  
  // useForm のセットアップ
  const {
    register, // 入力項目を登録する関数
    handleSubmit, // 送信ハンドラ
    formState: { errors }, // フォームの状態（エラー情報など）
  } = useForm<ItemInput>({
    // ZodスキーマをReact Hook Formに接続
    resolver: zodResolver(itemSchema),
    defaultValues: {
      name: "",
      price: 0,
      description: "",
    },
  });

  // バリデーションが成功したときだけ呼ばれる関数
  const onSubmit = async (data: ItemInput) => {
    // data は既にバリデーション済みかつ適切な型（数値など）に変換されている
    await mutateAsync(data);
  };

  return (
    <Paper sx={{ p: 4, maxWidth: 600, mx: "auto", mt: 4 }}>
      <Typography variant="h5" component="h1" gutterBottom sx={{ mb: 3 }}>
        商品作成
      </Typography>
      
      {/* エラーメッセージの表示 */}
      {errorMessage && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {errorMessage}
        </Alert>
      )}

      {/* handleSubmitでラップすることで、送信前にバリデーションが実行される */}
      <Box component="form" onSubmit={handleSubmit(onSubmit)} noValidate sx={{ display: "flex", flexDirection: "column", gap: 3 }}>
        <TextField
          label="商品名"
          required
          fullWidth
          disabled={isSubmitting}
          // エラーオブジェクトが存在するかどうかを boolean に変換
          error={!!errors.name}
          // Zod で定義したエラーメッセージを表示
          helperText={errors.name?.message}
          // スプレッド構文で展開（onChange, onBlur, name, ref などが含まれる）
          {...register("name")}
        />
        <TextField
          label="価格"
          type="number"
          required
          fullWidth
          disabled={isSubmitting}
          error={!!errors.price}
          helperText={errors.price?.message}
          // valueAsNumber: true で数値を数値として扱う
          {...register("price", { valueAsNumber: true })}
        />
        <TextField
          label="商品説明"
          multiline
          rows={4}
          fullWidth
          disabled={isSubmitting}
          error={!!errors.description}
          helperText={errors.description?.message}
          {...register("description")}
        />
        
        <Box sx={{ display: "flex", justifyContent: "flex-end", gap: 2, mt: 2 }}>
          <Button
            variant="outlined"
            href="/items"
            disabled={isSubmitting}
          >
            キャンセル
          </Button>
          <Button 
            type="submit" 
            variant="contained" 
            disabled={isSubmitting}
          >
            {isSubmitting ? "登録中..." : "登録"}
          </Button>
        </Box>
      </Box>
    </Paper>
  );
}
```

### 9.2.4 実装のポイント

**1. 入力項目の登録 (`register`)**

`register` は、入力フォーム（TextFieldなど）を React Hook Form と「接続」するための関数です。
`{...register("name")}` と記述することは、実質的に以下のようなコードを書いているのと同じことになります。

**React Hook Form を使う場合:**

```tsx
<TextField
  label="商品名"
  {...register("name")}
/>
```

**これと同じ意味になります（展開後のイメージ）:**

```tsx
<TextField
  label="商品名"
  // 以下が register("name") によって自動的に設定されます
  name="name"
  onChange={(e) => { /* 入力値を React Hook Form の状態に反映 */ }}
  onBlur={(e) => { /* フォーカスが外れた時にバリデーションを実行 */ }}
  ref={(e) => { /* 要素への参照を React Hook Form に渡す */ }}
/>
```

つまり、`register` を使うことで、**「入力値の管理(onChange)」「バリデーションのトリガー(onBlur)」「要素の参照(ref)」** といった面倒な設定を、たった一行で自動的に行うことができます。

**2. 数値の扱い (`valueAsNumber`)**

`TextField` に `type="number"` を指定することで数値入力用のUIになりますが、HTMLの仕様上、内部的な値は「文字列」として扱われます。
Zodスキーマでは `price: z.number()` と定義しているため、このままでは型エラーになります。
そこで `register("price", { valueAsNumber: true })` を指定することで、React Hook Form が値を自動的に数値型に変換してくれます。

**3. エラー情報の取得 (`formState.errors`)**

`formState.errors` は、**「現在発生しているバリデーションエラー」** が格納されているオブジェクトです。
Zod スキーマのチェックに引っかかった項目だけが、ここに含まれます。

例えば、「商品名」が未入力の場合、`errors` オブジェクトは以下のようになります。

```javascript
// エラー発生時の errors オブジェクト（イメージ）
{
  name: {
    message: "商品名は必須です", // Zodで定義したメッセージ
    type: "min",
    // ...
  },
  // price や description にエラーがなければ、それらは undefined
}
```

これを利用して、UIの表示を制御しています。

*   `error={!!errors.name}`: `errors.name` が存在すれば `true` になり、TextField が赤枠になります。
*   `helperText={errors.name?.message}`: エラーがある場合のみ、そのメッセージ（"商品名は必須です"）を表示します。

**4. 送信処理の流れ**

フォーム送信時の処理フローは以下のようになります。

1.  ユーザーが「登録」ボタンを押す。
2.  `handleSubmit(onSubmit)` が実行される。
3.  **React Hook Form が Zod スキーマを使ってバリデーションを実行する。**
    *   **失敗した場合**: `onSubmit` は実行されず、画面にエラーメッセージが表示される。
    *   **成功した場合**: バリデーション済みのデータを受け取り、`onSubmit` 関数を実行する。
4.  `onSubmit` 内で `mutateAsync` を呼び出し、APIリクエストを行う。

この仕組みにより、「バリデーションを通過した正しいデータ」だけが API に送信されることが保証されます。

## 9.3 まとめ

React Hook Form と Zod を導入することで、以下のメリットが得られました。

1.  **宣言的なバリデーション**: `schema.ts` を見るだけで、どのような入力ルールがあるかが一目瞭然になりました。
2.  **型安全性**: バリデーションを通過したデータ（`onSubmit` の引数）は、確実にスキーマ通りの型であることが保証されます。
3.  **コードの簡素化**: バリデーションロジックやエラーメッセージの管理をライブラリに任せることで、コンポーネントのコードがシンプルになりました。

