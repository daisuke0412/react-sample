# 7. TanStack Query によるデータ管理

本章では、**TanStack Query (React Query)** を導入して、データ（サーバー状態）の管理を効率化します。

## 7.1 TanStack Query とは

Webアプリケーションでのデータ取得（サーバー状態管理）やデータ更新を自前で実装しようとすると、以下のような課題に直面します。

*   **キャッシュ管理が難しい**: 標準的なAPI呼び出し（useEffectやclientLoader）では、取得したデータをキャッシュできず、基本的にアクセスのたびにデータ取得が発生してしまいます。
*   **データの鮮度管理**: 「データが古くなったら再取得する」「ウィンドウにフォーカスが戻ったら最新化する」といった高度な制御を実装するには、複雑なコードが必要になります。
*   **更新処理の複雑さ**: データ更新（Mutation）時の「通信中」「成功」「失敗」といった状態管理や、更新後のデータ再取得ロジックが複雑になりがちです。
*   **リクエストの重複**: 複数のコンポーネントで同じデータを必要とする場合、調整しないと無駄な重複リクエストが発生します。

TanStack Query は、これらの問題を解決するライブラリです。
強力なキャッシュ機能とデータ更新機能により、「サーバーからのデータ取得、キャッシュ、更新」を驚くほど簡単に扱えるようになります。
React Router Frameworkモードと組み合わせることで、より強力なデータ管理が可能になります。

## 7.2 セットアップ

### 7.2.1 インストール

まずはパッケージをインストールします。

```bash
pnpm add @tanstack/react-query
```

### 7.2.2 QueryClient の設定

TanStack Query の設定とインスタンスを管理するファイルを作成します。ここでは、グローバルな設定（デフォルトのキャッシュ時間など）も定義します。

`queries`に設定した値は`useQuery`を利用したデータ取得に、`mutation`に設定した値は`useMutation`を利用したデータ更新の挙動に影響します。詳細は後続の章で解説します。  

**app/core/api/query-client.ts**

```typescript
import { QueryClient, type DefaultOptions } from '@tanstack/react-query';

export const queryConfig = {
  queries: {
    refetchOnWindowFocus: false,
    retry: false,
    staleTime: 1000 * 60,
  },
  mutations: {
    retry: false,
  },
} satisfies DefaultOptions;

export const queryClient = new QueryClient({ defaultOptions: queryConfig });
```

### 7.2.3 プロバイダーの適用

アプリ全体で TanStack Query を使えるように、`root.tsx` で `QueryClientProvider` を設定します。

**app/root.tsx**

```typescript
import { QueryClientProvider } from "@tanstack/react-query"; // 追加
import { queryClient } from "./core/api/query-client"; // 追加

export default function App() {
  return (
    <ThemeProvider theme={theme}>
      <QueryClientProvider client={queryClient}>
        <CssBaseline />
        <SampleLayout>
          <Outlet />
        </SampleLayout>
      </QueryClientProvider>
    </ThemeProvider>
  );
}
```

## 7.3 useQuery によるデータ取得

商品一覧ページに「検索機能」を追加しながら、`useQuery` の使い方を学びます。

この章では下記ブランチを利用します。  
`ch7-3/useQuery`

### 7.3.1 useQuery のメリット

`useQuery` は、データの取得（Fetch）・キャッシュ・同期を管理するためのフックです。
これを利用することで、単にデータを取得するだけでなく、以下のような機能を利用できます。

*   **キャッシュ管理**: 一度取得したデータをメモリに保存し、不要なネットワーク通信を削減します。
*   **バックグラウンド更新**: キャッシュが古い場合、古いデータを即座に表示しつつ、裏側で最新データを取得して画面を更新します。
*   **定期的な自動データ更新**: 設定値に応じてデータを自動で再取得します。
*   **エラーリトライ**: バックエンド通信に失敗した場合、自動でリトライします。

### 7.3.2 useQuery の基本動作

#### クエリ実行/データ取得

`useQuery` を使用したデータ取得の基本的な実装パターンは以下の通りです。  
`queryOptions` に`queryKey（クエリを識別するキー）`、`queryFn（クエリ処理本体）`などを設定し、それを `useQuery` に設定することでデータ取得を行います。  
`queryOptions` に設定された `queryKey` が変更されると、TanStack Query は自動的にデータ取得（またはキャッシュの返却）を行います。

本アプリケーションの実装では、検索キーワード（`searchName`）を `queryKey` に含めているため、以下のタイミングでデータの取得やキャッシュの参照が行われます。

*   **画面初期表示時**: `queryKey` は `['items', 'list', { name: "" }]` となり、全件取得が行われます。
*   **検索実行時**: `searchName` が更新されると `queryKey` が `['items', 'list', { name: "検索文字" }]` に変化し、検索結果の取得が行われます。

```typescript
export function useItems() {
  const [searchName, setSearchName] = useState("");

  // queryOptions の定義
  // searchName に依存して queryKey が変化する
  const options = queryOptions({
    queryKey: ['items', 'list', { name: searchName }],
    queryFn: () => api.get<Item[]>("/items", { params: { name: searchName } }),
  });

  // useQuery の実行
  const { data, status, error } = useQuery(options);

  // ...
}
```

#### キャッシュ

`useQuery` は、`queryKey` を一意なキーとして、これらのクエリ実行結果をキャッシュしています。  
初期表示時や `queryKey` 更新時にすぐデータ取得を実行するのではなく、まず `queryKey` と一致するキャッシュがないか検索します。

そして一致するキャッシュがあった場合はキャッシュデータを返却し、ない場合はデータ取得を実行します。

また、キャッシュされるデータは単なるAPIレスポンスだけでなく、以下のようなメタ情報（ステータスやエラー情報など）を含んだオブジェクトとして管理されます。
これらの値を使うことで、UI側でのローディング表示やエラーハンドリングが容易になります。

```typescript
// TanStack Query内部で管理されているキャッシュ（=useQueryの返却値）のイメージ
{
  queryKey: ['items', 'list', { name: '...' }],
  state: {
    data: [...],                // APIから取得したデータ
    status: 'success',          // 'pending' | 'success' | 'error'
    error: null,                // エラーオブジェクト
    dataUpdatedAt: 1732850000,  // データ取得時間
    isStale: false,             // stale状態フラグ
    // ...省略...
  }
}
```

しかし、キャッシュが古い場合は、再度データ取得を実行しデータを更新すべきです。  
そこでTanStack Query は、下記のような場合にキャッシュが「古い (stale) / invalidate（無効）」とみなし、**即座に古いキャッシュを返却しつつ、バックグラウンドでデータ取得を実行します。**

*   **データ取得から staleTime が経過した場合**: `staleTime`（保持期間）を過ぎると、そのデータは古いと判断されます。
*   **invalidateQueries が実行された場合**: 明示的にキャッシュを無効化することで、強制的に古い状態に変更されます。

### 7.3.3 useQuery によるデータ取得フロー

ここまでのデータ取得パターンをまとめると、下記3通りになります。

- **キャッシュがあり、fresh状態の場合**: 即座にキャッシュを返却する
- **キャッシュがあり、stale状態の場合**: 即座にキャッシュを返却し、バックグラウンドでデータ再取得、キャッシュの更新、データ返却を行う
- **キャッシュがない場合**: データ取得、キャッシュの追加、データ返却を行う

```mermaid
sequenceDiagram
  participant Component as コンポーネント<br>カスタムフック
  participant TQ as TanStack Query
  participant API as バックエンドAPI

  Component->>TQ: useQuery 実行<br>（=queryKeyの設定/更新）
  TQ->>TQ: クエリキーでキャッシュ検索
  alt クエリキーに紐づくキャッシュあり
    TQ->>TQ: キャッシュのfresh/stale判定
    alt 実行結果がfresh状態の場合
      TQ-->>Component: キャッシュを返却
    else 実行がstale状態の場合
      TQ-->>Component: キャッシュを返却
      TQ->>API: バックグラウンドでAPI リクエスト
      API-->>TQ: レスポンス
      TQ->>TQ: キャッシュを更新
      TQ-->>Component: 実行結果（データやエラー）を返却
    end
  else クエリキーに紐づくキャッシュなし
    TQ->>API: API リクエスト
    API-->>TQ: レスポンス
    TQ->>TQ: キャッシュに追加
    TQ-->>Component: 実行結果（データやエラー）を返却
  end
```

### 7.3.4 実装例

それでは検索機能を開発していきます。
まず、検索クエリを受け取れるように `mock_server/server.js` を少し修正します。

**mock_server/server.js**

```javascript
// GET /items
app.get('/items', (req: Request, res: Response) => {
  // テスト用エラーコード
  // res.status(500).json();

  console.log('GET /items', req.query);
  const name = req.query.name as string | undefined;
  
  let result = items;
  if (name) {
    result = result.filter(item => item.name.includes(name));
  }
  
  res.json(result);
});
```

**app/features/items/api.ts**

`api.ts` の `getItems` を、検索キーワードを受け取れるように修正します。

```typescript
// ... imports

export const getItems = async (name?: string) => {
  // params オプションでクエリパラメータを渡す
  return await api.get<Item[]>("/items", {
    params: { name },
  });
};
```

**app/features/items/api.ts**

`queryOptions` を定義します。`queryKey` については管理しやすいよう別ファイルに定義します。

```typescript
import { queryOptions } from "@tanstack/react-query";
import { itemKeys } from "./query-keys";

// ... existing code ...

export const getItemsQueryOptions = (name?: string) => {
  return queryOptions({
    // キャッシュ検索のためのキー
    queryKey: itemKeys.list(name),
    // 実行するクエリ
    queryFn: () => getItems(name),
    // クエリリトライ回数
    // retry: 3
    // キャッシュをstaleと判定する閾値
    // staleTime: 1000 * 180 
    // などを設定可能
  });
};
```

**app/features/items/query-keys.ts**

```typescript
export const itemKeys = {
  all: ["items"] as const,
  list: (name?: string) => [...itemKeys.all, "list", { name }] as const,
  detail: (id: string) => [...itemKeys.all, "detail", id] as const,
};
```

**app/features/items/hooks/useItems.ts**

コンポーネントから直接 `useQuery` を呼ぶのではなく、カスタムフック `useItems` を作成してデータ取得ロジックを分離します。

```typescript
export function useItems() {
  // ...other code...

  const [searchName, setSearchName] = useState("");

  // useQuery 実行
  // 戻り値として、データ(data)や状態(status)を含む実行結果オブジェクトが返される
  const result = useQuery(getItemsQueryOptions(searchName));

  // 実行結果オブジェクトから必要なデータを取り出す
  const { data } = result;

  // ...other code...

  const handleSearch = (name: string) => {
    setSearchName(name);
  };

  return {
    headerProps: {
      onRefresh: handleRefresh,
    },
    listProps: {
      items: data || [],
      onItemClick: handleItemClick,
    },
    searchProps: {
      onSearch: handleSearch,
    },
  };
}

```
**app/features/items/components/ItemSearch.tsx**
```ts
export function ItemSearch({ onSearch }: ItemSearchProps) {
  const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const formData = new FormData(event.currentTarget);
    const name = formData.get("name") as string;
    onSearch(name);
  };

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ mb: 3, display: 'flex', gap: 1, maxWidth: 300 }}>
      <TextField
        name="name"
        label="商品名で検索"
        size="small"
        fullWidth
        placeholder="検索キーワードを入力"
        sx={{ bgcolor: "background.paper" }}
      />
      <Button type="submit" variant="contained">
        <SearchIcon />
      </Button>
    </Box>
  );
}
```

### 7.3.5 動作検証

ここまでの実装で、 `useQuery` を使った検索ができるようになりました。
TanStack Query の強力なキャッシュ機能を体感するために、少し設定を変更して動作検証を行ってみましょう。

**1. 準備: モックサーバーの遅延設定**

「データ取得中」の状態を分かりやすくするため、モックサーバーのレスポンスを5秒遅らせます。
`mock_server/server.js` の `GET /items` に `setTimeout` を追加します。

```javascript
// mock_server/server.js
app.get('/items', (req, res) => {
  // ... (省略) ...
  if (name) {
    result = result.filter(item => item.name.includes(name));
  }
  
  // 5秒遅延させてレスポンスを返す
  setTimeout(() => {
    res.json(result);
  }, 5000);
});
```

**2. 準備: staleTime の短縮**

キャッシュがすぐに「古く（Stale）」なるように、`app/core/api/query-client.ts` の `staleTime` を一時的に **10秒** に変更します。

```typescript
// app/core/api/query-client.ts
staleTime: 1000 * 10, // 10秒
```

**3. 動作確認**

ブラウザの開発者ツール（Networkタブ）を開き、`Fetch/XHR` フィルタを有効にして確認します。
検索機能を使って、キャッシュの挙動を確認してみましょう。

| テストケース | 操作 | 画面の挙動 | 解説 |
| :--- | :--- | :--- | :--- |
| **初回検索** | 検索ボックスに「イヤホン」と入力して検索 | ローディング後に検索結果が表示される | キャッシュがないため、APIからデータを取得する。 |
| **Fresh状態** | 検索ワードを消した状態で全件検索し、**すぐに**再度「イヤホン」で検索 | **一瞬で表示** | データ取得から10秒以内のため、キャッシュ（Fresh）が使われる。API通信は発生しない。 |
| **Stale状態** | **10秒以上待ってから**、再度「イヤホン」で検索 | **一瞬で表示**され、その後最新状態に更新 | キャッシュはあるが「古い(Stale)」ため、**古いキャッシュを一瞬で表示しつつ、バックグラウンドでAPIリクエスト**を実行 |

このように、TanStack Query を使うことで、**「ユーザーを待たせないUI」** と **「データのバックグラウンド更新」** を両立できていることが分かります。

確認ができたら、変更した設定（`server.js`, `query-client.ts`）を元に戻して次へ進みましょう。


### 7.3.6 検索処理の流れ

今回実装した検索処理の流れをシーケンスに表すと次のようになります。

::: mermaid
sequenceDiagram
  participant User
  participant Items as ItemsPage
  participant Search as ItemSearch
  participant Hook as useItems
  participant API as api.ts
  participant TQ as TanStack Query<br>(useQuery)
  participant Backend as Backend API

  User->>Search: 検索実行
  Search->>Hook: onSearch(name) で searchName 更新
  Hook->>API: getItemsQueryOptions(name) 呼び出し
  API-->>Hook: queryOptions (新しいqueryKey) を返却
  Hook->>TQ: useQuery(options) 再実行
  
  TQ->>TQ: クエリキーでキャッシュ確認

  alt キャッシュあり (Fresh)
    TQ-->>Hook: キャッシュデータを返却
    Hook-->>Items: キャッシュデータを返却
    Items-->>User: 検索結果表示
  else キャッシュあり (Stale)
    TQ-->>Hook: キャッシュデータを返却
    Hook-->>Items: キャッシュデータを返却
    Items-->>User: 検索結果表示
    TQ->>Backend: バックグラウンドでデータ取得
    Backend-->>TQ: レスポンス
    TQ->>TQ: キャッシュ更新
    TQ-->>Hook: 最新データを返却
    Hook-->>Items: 最新データを返却
    Items-->>User: 検索結果更新
  else キャッシュなし
    TQ->>Backend: データ取得
    Backend-->>TQ: レスポンス
    TQ->>TQ: キャッシュ保存
    TQ-->>Hook: データを返却
    Hook-->>Items: データを返却
    Items-->>User: 検索結果表示
  end
:::

### 7.3.7 まとめ

本節では、`useQuery` を用いたデータ取得について解説しました。
TanStack Query は、単なるデータ取得だけでなく、以下のような高度な機能を自動で提供してくれます。

*   **キャッシュ管理**: 不要なリクエストの削減
*   **バックグラウンド更新**: 常に最新のデータを表示
*   **ローディング・エラー状態の管理**: 宣言的なUI実装

これらを自前で実装しようとすると、複雑な状態管理や条件分岐が必要になり、バグの温床となりがちです。
TanStack Query を利用することで、**「高度なデータ管理」** を **「少ないコード」** で実現できます。

最初は概念の理解に少し慣れが必要ですが、現代のReact開発においてはデファクトスタンダードとも言える強力なライブラリですので、ぜひマスターしてください。

## 7.4 clientLoader によるプリフェッチ (fetchQuery)

この章では下記ブランチを利用します。  
`ch7-4/fetchQuery`

### 7.4.1 現状の課題

現状の実装では、`clientLoader` と TanStack Query の `useQuery` の両方でデータ取得を行っています。
特に `clientLoader` では TanStack Query の機能を使わずにデータを取得しており、その結果は画面表示には使われていません。
これは無駄なデータ取得処理（二重リクエスト）が発生している状態です。

### 7.4.2 clientLoader で TanStack Query を利用する

そこで、**`clientLoader` 内で TanStack Query を使ったデータ取得を行う** ように修正します。

ただし、`clientLoader` は React コンポーネントではないため、フックである `useQuery` は利用できません。
代わりに、`queryClient.fetchQuery` メソッドを使用します。

`fetchQuery` は、`useQuery` と異なり**画面更新（再レンダリング）は行わず、データの取得のみを行う非同期関数**です。
指定したクエリキーに紐づくキャッシュが存在しない、またはデータが古い（Stale）場合のみデータ取得を行います。

これを利用して、以下の流れを作ります。

1.  `clientLoader` で `fetchQuery` を実行し、事前にデータをキャッシュに溜める。
    *   **重要**: この時、コンポーネント側の `useQuery` と**全く同じ `queryOptions` (queryKey)** を指定することで、キャッシュを共有させます。
2.  画面レンダリング時には既にキャッシュがある状態にする。
3.  コンポーネントの `useQuery` は、そのキャッシュを即座に読み取って表示する。

これにより、コンポーネント側では「データ取得待ち」の状態がほとんど発生しなくなるため、ローディング表示の考慮を大幅に減らすことができます。

具体的な処理の流れは以下のようになります。

```mermaid
sequenceDiagram
  autonumber
  participant User
  participant Route as React Router
  participant Component as コンポーネント<br>ItemsPage
  participant Loader
  participant TQ as TanStack Query<br>(useQuery)
  participant API as Backend API

  User->>Route: ページアクセス
  Route->>Loader: clientLoader実行
  Loader->>TQ: fetchQuery 実行<br>クエリキー: ['items', list, {name: ""}]
  TQ->>API: API リクエスト
  API-->>TQ: レスポンス
  TQ->>TQ: キャッシュに追加
  Loader->>Route: clientLoader完了
  Route->>Component: レンダリング開始
  Component->>TQ: useQuery 実行<br>クエリキー: ['items', list, {name: ""}]
  TQ->>TQ: キャッシュあり
  TQ-->>Component: データを返却
  Component->>User: 画面表示（データあり）
```

### 7.4.3 実装例

**1. API定義とQuery Options**

※7.3.4 で実装済みのため、変更はありません。

```typescript
import { api } from "~/core/api/api-client";
import { queryOptions } from "@tanstack/react-query";
import type { Item } from "./types";

// ... itemKeys ...

export const getItems = async (name?: string) => {
  return await api.get<Item[]>("/items", {
    params: { name },
  });
};

export const getItemsQueryOptions = (name?: string) => {
  return queryOptions({
    queryKey: itemKeys.list(name),
    queryFn: () => getItems(name),
  });
};
```

**2. clientLoaderの実装**

`app/features/items/hooks/useItemsRoute.ts`

```typescript
import { queryClient } from "~/lib/query-client";
import { getItemsQueryOptions } from "../api";

export const useItemsRouteHandlers = {
  clientLoader: async () => {
    // 画面初期表示時点のクエリキー（name=""）と同じクエリキーでfetchQueryを実行する
    // これにより、初期表示時のデータ取得を待機できる
    await queryClient.fetchQuery(
      getItemsQueryOptions()
    );
    
    return null;
  },
};
```

**3. コンポーネントでの利用**

※7.3.5 で実装済みのため、変更はありません。

```typescript
import { useSearchParams } from "react-router";
import { useQuery } from "@tanstack/react-query";
import { getItemsQueryOptions } from "../api";
import { Box, Alert } from "@mui/material";
// ... imports

export function ItemsPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  const name = searchParams.get("name") || "";

  // キャッシュがあれば即座にデータが返る
  // エラー時は throwOnError により ErrorBoundary が表示される
  const { data: items } = useQuery(
    getItemsQueryOptions(name)
  );

  // ... render
}
```

### 7.4.4 動作検証

`clientLoader` によるプリフェッチの効果を確認します。
モックサーバーの遅延（5秒）が有効な状態で確認すると違いが分かりやすいです。

| テストケース | 設定 | 画面の挙動 | 解説 |
| :--- | :--- | :--- | :--- |
| **clientLoader 有効**<br>(プリフェッチあり) | デフォルト状態 | データ取得完了まで画面遷移が待機され、遷移後は即座にデータが表示される | `fetchQuery` により事前にデータが取得されるため、遷移直後からデータがある状態で表示できる。 |
| **clientLoader 無効**<br>(プリフェッチなし) | `app/routes/items._index.tsx` の<br>`clientLoader` をコメントアウト | 即座に画面遷移するが、遷移直後はデータが表示されず、少し遅れて表示される | 遷移後にコンポーネントがマウントされてから `useQuery` が走るため、データ取得の待ち時間が発生する。 |

### 7.4.5 まとめ

`clientLoader` で `fetchQuery` を使うことで、「データ取得完了まで画面遷移を待つ」という挙動になります。
これにより、ユーザー体験の向上（ガタつきのない表示）などが期待できます。


## 7.5 useMutation によるデータ更新

この章では下記ブランチを利用します。  
`ch7-5/useMutation`

### 7.5.1 useMutation の更新処理

`useMutation` は、データの作成・更新・削除（Mutation）を行うためのフックです。  
`useQuery` がコンポーネントのマウント時や `queryKey` 更新時に自動的に実行されるのに対し、`useMutation` は任意のタイミングで実行できる関数（`mutate` または `mutateAsync`）を提供します。

`useMutation` を使用したデータ更新の基本的な実装パターンは以下の通りです。  
`mutationFn` に処理の本体（APIリクエストなど）を設定し、`onSuccess` や `onError` などのパラメータにその前後に実行する処理（キャッシュ無効化や画面遷移、エラーログなど）を定義することで、一連の更新処理を定義します。

`useMutation` からは、上記の一連の処理を実行するための**実行関数**と、その**実行結果オブジェクト**を受け取れます。

```typescript
export function useItemCreate() {
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  // useMutation の定義
  const mutation = useMutation({
    // 実行する非同期処理（APIリクエストなど）
    mutationFn: (newItem: CreateItemParams) => createItem(newItem),
    // 成功時の処理
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: itemKeys.all });
      navigate("/items");
    },
    // エラー時の挙動制御（trueを返すとErrorBoundaryに伝播する）
    throwOnError: (error) => {
      if (isAxiosError(error) && error.response?.status === 400) {
        return false;
      }
      return true;
    },
    // // エラー時の処理
    // onError: (error) => console.error(error),
    // // mutateFnの直前に実行される処理
    // onMutate: (variables) => {
    //   console.log("送信開始！送信内容:", variables);
    //   setIsLoading(true);
    // },
  });

  // 実行結果オブジェクトから実行結果と非同期実行関数を取り出す
  const { mutateAsync, isPending, error } = mutation;

  return {
    mutateAsync,
    isSubmitting: isPending,
    errorMessage: error?.toString(),
  };
}

export function ItemCreatePage() {
  const { mutateAsync, isSubmitting, errorMessage } = useItemCreate();

  // 商品作成処理
  const handleSubmit = async (data: ItemInput) => {
    // 実行関数の呼び出し
    await mutateAsync(data);
  };

  // ...
}
```

`useMutation` の戻り値（実行結果オブジェクト）のイメージは以下の通りです。  
ここに含まれる `status` や `isPending`、`error` などの値を参照することで、画面上に「送信中...」というローディング表示や、エラーメッセージの表示を簡単に実装できます。

```typescript
// TanStack Query の Mutation で管理される実行結果オブジェクト（=useMutationの戻り値）のイメージ
{
  // 実行関数
  mutate: (variables) => void,           // 同期的な実行関数（エラーハンドリングが必要）
  mutateAsync: (variables) => Promise<TData>,  // 非同期的な実行関数（await可能）

  // 実行結果（状態）
  status: 'idle',               // 'idle' | 'pending' | 'success' | 'error'
  isPending: false,             // 実行中かどうか
  isSuccess: false,             // 成功したかどうか
  isError: false,               // 失敗したかどうか
  data: undefined,              // 成功時のレスポンスデータ
  error: null,                  // エラーオブジェクト（ApiValidationErrorなど）
  variables: undefined,         // mutate実行時に渡した引数
  submittedAt: 0,               // mutate実行時刻
  // ...省略...
}
```

### 7.5.2 clientAction との併用について

React Router の `clientAction` はフォーム送信をベースにした強力な機能ですが、TanStack Query の `useMutation` とは役割が競合するため、基本的には併用せずどちらか一方を選択します。

本プロジェクトでは、以下の理由から `useMutation` を採用します。

1.  **ロジックの集約**: 「APIを叩く」「成功したら画面遷移」「失敗したらエラー表示」といった一連の処理を、`onSuccess`、`onError`などにまとめて記述できるため、コードをシンプルに保てます。
2.  **直観的な分岐処理**: 成功時 (`onSuccess`) や失敗時 (`onError`) に実行したい処理（トースト表示やリダイレクトなど）を、複雑な条件分岐なしで直感的に記述できます。
3.  **データ取得との統一**: データ取得 (`useQuery`) と同じライブラリで統一することで、更新後に「キャッシュを無効化して再取得 (`invalidateQueries`)」する連携がスムーズに行えます。

### 7.5.3 実装例

**カスタムフック: app/features/items/hooks/useItemCreate.ts**

```typescript
export function useItemCreate() {
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  // useMutation 実行
  // 戻り値として、データ(data)や状態(status)を含む実行結果オブジェクトや、実行関数が返される
  const mutation = useMutation({
    mutationFn: (newItem: CreateItemParams) => createItem(newItem),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: itemKeys.all });
      navigate("/items");
    },
    // throwOnError=trueの場合、エラー時にErrorBoundaryに投げる
    throwOnError: (error) => {
      // 400エラー（バリデーションエラー）以外はErrorBoundaryに投げる
      if (isAxiosError(error) && error.response?.status === 400) {
        return false;
      }
      return true;
    },
  });

  // 実行結果オブジェクトから必要なデータと非同期実行関数を取り出す
  const { mutateAsync, isPending, error } = mutation;

  return {
    mutateAsync,
    isSubmitting: isPending,
    errorMessage: error?.toString(),
  };
}
```

**コンポーネント: app/features/items/pages/ItemCreatePage.tsx**

```typescript
import { useItemCreate } from "../hooks/useItemCreate";
import { Box, Button, TextField, Alert, Paper, Typography } from "@mui/material";
import type { CreateItemParams } from "../types";

export function ItemCreatePage() {
  const { mutateAsync, isSubmitting, errorMessage } = useItemCreate();
  
  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const formData = new FormData(event.currentTarget);
    
    const newItem: CreateItemParams = {
      name: formData.get("name") as string,
      price: Number(formData.get("price")),
      description: formData.get("description") as string,
    };

    await mutateAsync(newItem);
  };

  return (
    <Paper sx={{ p: 4, maxWidth: 600, mx: "auto", mt: 4 }}>
      <Typography variant="h5" component="h1" gutterBottom sx={{ mb: 3 }}>
        商品作成
      </Typography>
      
      {/* エラーメッセージの表示 */}
      {errorMessage && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {errorMessage}
        </Alert>
      )}

      <Box component="form" onSubmit={handleSubmit} noValidate sx={{ display: "flex", flexDirection: "column", gap: 3 }}>
        <TextField
          name="name"
          label="商品名"
          required
          fullWidth
          disabled={isSubmitting}
        />
        <TextField
          name="price"
          label="価格"
          type="number"
          required
          fullWidth
          disabled={isSubmitting}
        />
        <TextField
          name="description"
          label="商品説明"
          multiline
          rows={4}
          fullWidth
          disabled={isSubmitting}
        />
        
        <Box sx={{ display: "flex", justifyContent: "flex-end", gap: 2, mt: 2 }}>
          <Button
            variant="outlined"
            href="/items"
            disabled={isSubmitting}
          >
            キャンセル
          </Button>
          <Button 
            type="submit" 
            variant="contained" 
            disabled={isSubmitting}
          >
            {isSubmitting ? "登録中..." : "登録"}
          </Button>
        </Box>
      </Box>
    </Paper>
  );
}
```

### 7.5.4 商品作成の流れ

`useMutation` を利用することで、APIリクエストの実行状態（`isPending`）や結果（成功・失敗）に応じた処理を、宣言的かつ一元的に管理できます。
特に成功時の `onSuccess` コールバックで `invalidateQueries` を実行することで、データの更新と同時にキャッシュを無効化し、アプリケーション全体の整合性を保つことができます。

::: mermaid
sequenceDiagram
  autonumber
  participant User
  participant EB as ErrorBoundary
  participant Component as ItemCreatePage
  participant Hook as useItemCreate
  participant TQ as TanStack Query<br>(useMutation)
  participant API as Backend API

  User->>Component: 「登録」ボタン押下
  Component->>Hook: mutateAsync(newItem) 実行
  Hook->>TQ: mutateAsync 呼び出し
  note right of Hook: isPending = true に更新
  TQ-->>Hook: state更新
  Hook-->>Component: 再レンダリング (ボタン無効化など)
  TQ->>API: mutationFn 実行 (APIリクエスト)
  alt 成功 (Success)
    API-->>TQ: レスポンス (200 OK)
    TQ->>TQ: onSuccess 実行<br>(キャッシュ無効化・画面遷移)
    TQ-->>User: 商品一覧へリダイレクト
    note right of User: キャッシュ無効化により、遷移先の<br>商品一覧でデータ再取得が実行される
    
  else エラー (400 Bad Request)
    API-->>TQ: エラー (400)
    TQ->>TQ: throwOnError 判定<br>(400なので false を返却)
    note right of Hook: isPending = false, status = 'error' に更新
    TQ-->>Hook: state更新 (errorセット)
    Hook-->>Component: 再レンダリング (エラーメッセージ表示)
  else エラー (500 Server Error)
    API-->>TQ: エラー (500)
    TQ->>TQ: throwOnError 判定<br>(その他なので true を返却)
    TQ->>EB: エラーをThrow
    EB-->>User: エラー画面表示
  end
:::

### 7.5.5 動作検証

実装した商品作成機能の動作を確認します。
モックサーバー（`mock_server/server.ts`）の `POST /items` ハンドラ冒頭のコードを書き換えて、各ケースの挙動を確認してください。

| テストケース | 設定 (モックサーバー) | 期待される挙動 | 解説 |
| :--- | :--- | :--- | :--- |
| **成功 (Success)** | エラーを返さない状態<br>(デフォルト) | 商品一覧画面へ遷移し、新しい商品が表示される | `onSuccess` が実行され、`navigate` で遷移。`invalidateQueries` により一覧データが再取得される。 |
| **400 Error**<br>(バリデーションエラー) | `return res.status(400)...` を追加 | 画面遷移せず、フォーム上部にエラーメッセージが表示される | `throwOnError` が `false` を返すため、`useMutation` の `error` 状態が更新され、画面にアラートが表示される。 |
| **500 Error**<br>(サーバーエラー) | `return res.status(500)...` を追加 | ErrorBoundary が捕捉し、アプリ全体のエラー画面が表示される | `throwOnError` が `true` を返すため、例外がスローされ、React Router の `ErrorBoundary` が表示される。 |

### 7.5.6 まとめ

本節では、`useMutation` を用いたデータ更新について解説しました。
`useMutation` を利用することで、以下のようなメリットが得られます。

1.  **ロジックの集約**: 「APIを叩く」「成功したら画面遷移」「失敗したらエラー表示」といった一連の処理を、`onSuccess`、`onError`などにまとめて記述できるため、コードをシンプルに保てます。
2.  **直観的な分岐処理**: 成功時 (`onSuccess`) や失敗時 (`onError`) に実行したい処理（トースト表示やリダイレクトなど）を、複雑な条件分岐なしで直感的に記述できます。
3.  **データ取得との統一**: データ取得 (`useQuery`) と同じライブラリで統一することで、更新後に「キャッシュを無効化して再取得 (`invalidateQueries`)」する連携がスムーズに行えます。

これらを自前で実装する場合、`try-catch` や複雑な状態管理が必要になりますが、`useMutation` を使うことで、**シンプルかつ直感的で、変更に強い実装** が可能になります。



## 7.6 その他の便利機能

TanStack Query には、開発者体験とユーザー体験を向上させる多くの機能が備わっています。
ここでは、特によく利用される機能をいくつか紹介します。

この章では下記ブランチを利用します。  
`ch7-5/useMutation`

### 7.6.1 ウィンドウフォーカス時の再取得 (refetchOnWindowFocus)

ユーザーが別のタブやウィンドウを見てから、再びアプリケーションのタブに戻ってきた際に、自動的にデータを再取得（バックグラウンド更新）する機能です。
これにより、ユーザーは「更新ボタン」を押さなくても、常に最新の情報を目にすることができます。

**実装方法**

`queryOptions` または `useQuery` のオプションで設定します。
デフォルトでは `true`（有効）になっています。

```typescript
export const getItemsQueryOptions = () => {
  return queryOptions({
    queryKey: itemKeys.all,
    queryFn: getItems,
    // true: 有効 (デフォルト), false: 無効, 'always': 常に再取得
    refetchOnWindowFocus: true, 
  });
};
```

**UIへの影響**

- ユーザーがタブを切り替えて戻ってくると、画面上のデータが自動的に最新化されます。
- 再取得中もキャッシュが表示され続けるため、ユーザーは読み込み待ちを感じません。


### 7.6.2 ポーリング (refetchInterval)

一定間隔で自動的にデータを再取得する機能です。
リアルタイム性が求められるダッシュボードや、ステータス監視画面などで有用です。

**実装方法**

ミリ秒単位で間隔を指定します。

```typescript
export const getDashboardQueryOptions = () => {
  return queryOptions({
    queryKey: ['dashboard'],
    queryFn: getDashboardData,
    // 5秒ごとに再取得
    refetchInterval: 5000,
  });
};
```

**UIへの影響**

- 指定した間隔でデータが更新されます。
- ユーザーが操作していなくても、画面上の数値やグラフが最新の状態に保たれます。


### 7.6.3 依存クエリ (enabled)

「あるデータが取得できてから、次のデータを取得したい」といった依存関係や、「検索条件が入力されるまではリクエストを送りたくない」といった制御を実現します。
`enabled` オプションに `false` を渡すとクエリが無効化され、`true` になると自動的に実行されます。

**実装方法**

例えば、「検索キーワードが入力されている場合のみ検索APIを実行する」ケースです。

```typescript
const [name, setName] = useState("");

const { data: items } = useQuery({
  queryKey: ['items', name],
  queryFn: () => getItems(name),
  // name が空文字の場合は実行しない
  enabled: !!name, 
});
```

**UIへの影響**

*   初期表示時や入力が空の時に、無駄な全件取得リクエストを防げます。
*   ユーザーが検索ボタンを押すまで（あるいは入力するまで）データ取得を待機させることができます。


### 7.6.4 自動リトライ (retry)

API リクエストが失敗した際に、自動的に再試行を行う機能です。
一時的なネットワークエラーやサーバーの瞬断などが発生しても、ユーザーにエラー画面を見せることなく復旧できる可能性があります。

**実装方法**

`retry` オプションに回数（数値）または判定関数を指定します。
デフォルトでは `3` 回のリトライが行われます。

```typescript
export const getItemsQueryOptions = () => {
  return queryOptions({
    queryKey: itemKeys.all,
    queryFn: getItems,
    // 失敗時に1回だけリトライする
    retry: 1,
  });
};
```

**UIへの影響**

*   直接的な見た目の変化はありませんが、一時的なエラーで画面がクラッシュしたりエラーメッセージが表示されたりするのを防ぎ、アプリケーションの信頼性を向上させます。
*   リトライ中は `status` が `pending` のまま維持されるため、ユーザーは裏側でエラーが起きていることに気づきません。


## 7.7 まとめ

本章では、TanStack Query を導入して、サーバー状態管理を効率化する方法を学びました。

TanStack Query を導入する最大のメリットは、**「複雑な処理を、驚くほどシンプルに記述できる」** という点に尽きます。

1.  **複雑な状態管理からの解放**
    *   ローディング状態、キャッシュ管理、バックグラウンドでのデータ更新などを自前で実装しようとすると、膨大な分岐処理と状態管理が必要になります。TanStack Query はこれらをすべて隠蔽し、シンプルなフックとして提供してくれます。

2.  **直感的な副作用の制御**
    *   データ更新時の「前処理」「成功時」「失敗時」の処理も、自分で `try-catch` や条件分岐を書く必要はありません。`onMutate`, `onSuccess`, `onError` といったオプションで、直感的に記述できます。

その結果、コードは読みやすく変更に強いものになり、複雑な機能も短期間で開発できるようになります。
この「コードの分かりやすさ（仕様の理解や変更のしやすさ）」と「高い生産性」こそが、TanStack Query が近年のフロントエンド開発においてデファクトスタンダードと呼ばれる理由です。
